---
source: colvec-derive/src/lib.rs
expression: formatted
---
pub struct TestColVec<A: ::colvec::alloc::Allocator = ::colvec::alloc::Global> {
    buf: ::colvec::raw::RawColVec<Test, A>,
    len: usize,
}
impl TestColVec<::colvec::alloc::Global> {
    #[inline]
    #[must_use]
    pub const fn new() -> Self {
        Self {
            buf: ::colvec::raw::RawColVec::new(),
            len: 0,
        }
    }
}
const FIELDS: ::colvec::fields::Fields<4usize> = ::colvec::fields::Fields::from_sizes([
    size_of::<u8>(),
    size_of::<Option<u8>>(),
    size_of::<i16>(),
    size_of::<u32>(),
]);
impl ::colvec::raw::SmuggleOuter for Test {
    const LAYOUT: ::core::alloc::Layout = unsafe {
        let size = size_of::<u8>() + size_of::<Option<u8>>() + size_of::<i16>()
            + size_of::<u32>();
        let align = align_of::<Test>();
        ::core::alloc::Layout::from_size_align_unchecked(size, align)
    };
    unsafe fn move_fields(
        ptr: *mut u8,
        old_capacity: usize,
        new_capacity: usize,
        len: usize,
    ) {
        unsafe { FIELDS.move_fields(ptr, old_capacity, new_capacity, len) }
    }
}
impl<A: ::colvec::alloc::Allocator> TestColVec<A> {
    pub const fn capacity(&self) -> usize {
        self.buf.capacity()
    }
    #[inline]
    const fn as_ptr(&self) -> *const u8 {
        self.buf.ptr()
    }
    #[inline]
    const fn as_mut_ptr(&mut self) -> *mut u8 {
        self.buf.ptr()
    }
    pub fn push(&mut self, value: Test) {
        let len = self.len;
        if len == self.buf.capacity() {
            self.buf.grow_one();
        }
        unsafe {
            let end = self
                .as_mut_ptr()
                .add(self.buf.capacity() * FIELDS.offset_of(0usize))
                .cast::<u8>()
                .add(len);
            ::core::ptr::write(end, value.field0);
            let end = self
                .as_mut_ptr()
                .add(self.buf.capacity() * FIELDS.offset_of(1usize))
                .cast::<Option<u8>>()
                .add(len);
            ::core::ptr::write(end, value.field1);
            let end = self
                .as_mut_ptr()
                .add(self.buf.capacity() * FIELDS.offset_of(2usize))
                .cast::<i16>()
                .add(len);
            ::core::ptr::write(end, value.field2);
            let end = self
                .as_mut_ptr()
                .add(self.buf.capacity() * FIELDS.offset_of(3usize))
                .cast::<u32>()
                .add(len);
            ::core::ptr::write(end, value.field3);
        }
        self.len = len + 1;
    }
}
impl<A: ::colvec::alloc::Allocator> TestColVec<A> {
    pub const fn field0_slice(&self) -> &[u8] {
        unsafe {
            core::slice::from_raw_parts(
                self
                    .as_ptr()
                    .add(self.buf.capacity() * FIELDS.offset_of(0usize))
                    .cast::<u8>(),
                self.len,
            )
        }
    }
    pub const fn field0_slice_mut(&mut self) -> &mut [u8] {
        unsafe {
            core::slice::from_raw_parts_mut(
                self
                    .as_mut_ptr()
                    .add(self.buf.capacity() * FIELDS.offset_of(0usize))
                    .cast::<u8>(),
                self.len,
            )
        }
    }
    pub const fn field1_slice(&self) -> &[Option<u8>] {
        unsafe {
            core::slice::from_raw_parts(
                self
                    .as_ptr()
                    .add(self.buf.capacity() * FIELDS.offset_of(1usize))
                    .cast::<Option<u8>>(),
                self.len,
            )
        }
    }
    pub const fn field1_slice_mut(&mut self) -> &mut [Option<u8>] {
        unsafe {
            core::slice::from_raw_parts_mut(
                self
                    .as_mut_ptr()
                    .add(self.buf.capacity() * FIELDS.offset_of(1usize))
                    .cast::<Option<u8>>(),
                self.len,
            )
        }
    }
    pub const fn field2_slice(&self) -> &[i16] {
        unsafe {
            core::slice::from_raw_parts(
                self
                    .as_ptr()
                    .add(self.buf.capacity() * FIELDS.offset_of(2usize))
                    .cast::<i16>(),
                self.len,
            )
        }
    }
    pub const fn field2_slice_mut(&mut self) -> &mut [i16] {
        unsafe {
            core::slice::from_raw_parts_mut(
                self
                    .as_mut_ptr()
                    .add(self.buf.capacity() * FIELDS.offset_of(2usize))
                    .cast::<i16>(),
                self.len,
            )
        }
    }
    pub const fn field3_slice(&self) -> &[u32] {
        unsafe {
            core::slice::from_raw_parts(
                self
                    .as_ptr()
                    .add(self.buf.capacity() * FIELDS.offset_of(3usize))
                    .cast::<u32>(),
                self.len,
            )
        }
    }
    pub const fn field3_slice_mut(&mut self) -> &mut [u32] {
        unsafe {
            core::slice::from_raw_parts_mut(
                self
                    .as_mut_ptr()
                    .add(self.buf.capacity() * FIELDS.offset_of(3usize))
                    .cast::<u32>(),
                self.len,
            )
        }
    }
}
