---
source: colvec-derive/src/lib.rs
expression: formatted
---
pub struct TestColVec<A: ::colvec::alloc::Allocator = ::colvec::alloc::Global> {
    buf: ::colvec::raw::RawColVec<4usize, Test, A>,
    len: usize,
}
impl ::colvec::raw::StructInfo<4usize> for Test {
    const LAYOUT: ::core::alloc::Layout = unsafe {
        let size = Self::FIELDS.size();
        let align = align_of::<Test>();
        ::core::alloc::Layout::from_size_align_unchecked(size, align)
    };
    const FIELDS: ::colvec::fields::Fields<4usize> = ::colvec::fields::Fields::from_sizes([
        size_of::<u8>(),
        size_of::<Option<u8>>(),
        size_of::<i16>(),
        size_of::<u32>(),
    ]);
}
impl<A: ::colvec::alloc::Allocator> TestColVec<A> {
    #[inline]
    pub const fn new_in(alloc: A) -> Self {
        Self {
            buf: ::colvec::raw::RawColVec::new_in(alloc),
            len: 0,
        }
    }
    #[inline]
    #[track_caller]
    pub fn with_capacity_in(capacity: usize, alloc: A) -> Self {
        Self {
            buf: ::colvec::raw::RawColVec::with_capacity_in(capacity, alloc),
            len: 0,
        }
    }
    #[inline]
    pub const fn capacity(&self) -> usize {
        self.buf.capacity()
    }
    #[track_caller]
    pub fn reserve(&mut self, additional: usize) {
        self.buf.reserve(self.len, additional);
    }
    #[inline]
    const fn as_ptr(&self) -> *const u8 {
        self.buf.ptr()
    }
    #[inline]
    const fn as_mut_ptr(&mut self) -> *mut u8 {
        self.buf.ptr()
    }
    #[inline]
    pub unsafe fn set_len(&mut self, new_len: usize) {
        debug_assert!(new_len <= self.capacity());
        self.len = new_len;
    }
    pub fn push(&mut self, value: Test) {
        let len = self.len;
        if len == self.buf.capacity() {
            self.buf.grow_one();
        }
        unsafe {
            let end = self
                .as_mut_ptr()
                .add(
                    self.buf.capacity()
                        * <Test as ::colvec::raw::StructInfo<4usize>>::FIELDS
                            .offset_of(0usize),
                )
                .cast::<u8>()
                .add(len);
            ::core::ptr::write(end, value.field0);
            let end = self
                .as_mut_ptr()
                .add(
                    self.buf.capacity()
                        * <Test as ::colvec::raw::StructInfo<4usize>>::FIELDS
                            .offset_of(1usize),
                )
                .cast::<Option<u8>>()
                .add(len);
            ::core::ptr::write(end, value.field1);
            let end = self
                .as_mut_ptr()
                .add(
                    self.buf.capacity()
                        * <Test as ::colvec::raw::StructInfo<4usize>>::FIELDS
                            .offset_of(2usize),
                )
                .cast::<i16>()
                .add(len);
            ::core::ptr::write(end, value.field2);
            let end = self
                .as_mut_ptr()
                .add(
                    self.buf.capacity()
                        * <Test as ::colvec::raw::StructInfo<4usize>>::FIELDS
                            .offset_of(3usize),
                )
                .cast::<u32>()
                .add(len);
            ::core::ptr::write(end, value.field3);
        }
        self.len = len + 1;
    }
    #[inline]
    #[track_caller]
    pub fn append(&mut self, other: &mut Self) {
        unsafe {
            self.append_elements(other);
            other.set_len(0);
        }
    }
    /// Appends elements to `self` from other buffer.
    #[inline]
    #[track_caller]
    unsafe fn append_elements(&mut self, other: &Self) {
        let count = other.len();
        self.reserve(count);
        let len = self.len();
        unsafe {
            <Test as ::colvec::raw::StructInfo<4usize>>::FIELDS
                .move_fields(
                    other.as_ptr(),
                    self.as_mut_ptr(),
                    other.capacity(),
                    self.capacity(),
                    len,
                    count,
                )
        }
        self.len += count;
    }
    #[inline]
    pub const fn len(&self) -> usize {
        self.len
    }
}
impl<A: ::colvec::alloc::Allocator> TestColVec<A> {
    #[inline]
    pub const fn field0_slice(&self) -> &[u8] {
        unsafe {
            ::core::slice::from_raw_parts(
                self
                    .as_ptr()
                    .add(
                        self.buf.capacity()
                            * <Test as ::colvec::raw::StructInfo<4usize>>::FIELDS
                                .offset_of(0usize),
                    )
                    .cast::<u8>(),
                self.len,
            )
        }
    }
    #[inline]
    pub const fn field0_slice_mut(&mut self) -> &mut [u8] {
        unsafe {
            ::core::slice::from_raw_parts_mut(
                self
                    .as_mut_ptr()
                    .add(
                        self.buf.capacity()
                            * <Test as ::colvec::raw::StructInfo<4usize>>::FIELDS
                                .offset_of(0usize),
                    )
                    .cast::<u8>(),
                self.len,
            )
        }
    }
    #[inline]
    pub const fn field1_slice(&self) -> &[Option<u8>] {
        unsafe {
            ::core::slice::from_raw_parts(
                self
                    .as_ptr()
                    .add(
                        self.buf.capacity()
                            * <Test as ::colvec::raw::StructInfo<4usize>>::FIELDS
                                .offset_of(1usize),
                    )
                    .cast::<Option<u8>>(),
                self.len,
            )
        }
    }
    #[inline]
    pub const fn field1_slice_mut(&mut self) -> &mut [Option<u8>] {
        unsafe {
            ::core::slice::from_raw_parts_mut(
                self
                    .as_mut_ptr()
                    .add(
                        self.buf.capacity()
                            * <Test as ::colvec::raw::StructInfo<4usize>>::FIELDS
                                .offset_of(1usize),
                    )
                    .cast::<Option<u8>>(),
                self.len,
            )
        }
    }
    #[inline]
    pub const fn field2_slice(&self) -> &[i16] {
        unsafe {
            ::core::slice::from_raw_parts(
                self
                    .as_ptr()
                    .add(
                        self.buf.capacity()
                            * <Test as ::colvec::raw::StructInfo<4usize>>::FIELDS
                                .offset_of(2usize),
                    )
                    .cast::<i16>(),
                self.len,
            )
        }
    }
    #[inline]
    pub const fn field2_slice_mut(&mut self) -> &mut [i16] {
        unsafe {
            ::core::slice::from_raw_parts_mut(
                self
                    .as_mut_ptr()
                    .add(
                        self.buf.capacity()
                            * <Test as ::colvec::raw::StructInfo<4usize>>::FIELDS
                                .offset_of(2usize),
                    )
                    .cast::<i16>(),
                self.len,
            )
        }
    }
    #[inline]
    pub const fn field3_slice(&self) -> &[u32] {
        unsafe {
            ::core::slice::from_raw_parts(
                self
                    .as_ptr()
                    .add(
                        self.buf.capacity()
                            * <Test as ::colvec::raw::StructInfo<4usize>>::FIELDS
                                .offset_of(3usize),
                    )
                    .cast::<u32>(),
                self.len,
            )
        }
    }
    #[inline]
    pub const fn field3_slice_mut(&mut self) -> &mut [u32] {
        unsafe {
            ::core::slice::from_raw_parts_mut(
                self
                    .as_mut_ptr()
                    .add(
                        self.buf.capacity()
                            * <Test as ::colvec::raw::StructInfo<4usize>>::FIELDS
                                .offset_of(3usize),
                    )
                    .cast::<u32>(),
                self.len,
            )
        }
    }
}
impl TestColVec<::colvec::alloc::Global> {
    #[inline]
    #[must_use]
    pub const fn new() -> Self {
        Self {
            buf: ::colvec::raw::RawColVec::new_in(::colvec::alloc::Global),
            len: 0,
        }
    }
    #[inline]
    #[must_use]
    #[track_caller]
    pub fn with_capacity(capacity: usize) -> Self {
        Self::with_capacity_in(capacity, ::colvec::alloc::Global)
    }
}
